\documentclass{article}

\usepackage{listings}
\usepackage{xcolor}
\lstset { %
    language=Java,
    backgroundcolor=\color{black!5}, % set backgroundcolor
    basicstyle=\footnotesize,% basic font setting
}

\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{caption}
\usepackage{fancyhdr}
\usepackage{geometry}
	\geometry{height=24 cm}
	\geometry{left=2.5 cm}
	\geometry{right=2.5 cm}
	\geometry{top=2 cm}
	\geometry{headheight=1 cm}

\setcounter{secnumdepth}{2}


\title{\vspace{2cm}\textbf{Appunti di Algoritmi e\ Strutture Dati}}
\author{\vspace{3mm}4 ottobre 2022}
\date{\vspace{3mm} \textbf{Rosso Carlo}}

\begin{document}

\begin{titlepage}
	\maketitle
	\thispagestyle{empty}
\end{titlepage}
\tableofcontents
\newpage

\section{appello 1}

Date le seguenti classi:
\begin{lstlisting}
class Foo {
    Foo(int a) {
        // Costruttore Foo
    }
}

class Bar extends Foo {
static {
    // Inizializzatore statico
}
{
    // Inizializzatore
}
Bar(int a, String b) {
    super(a);
    // Costruttore Bar
    }
}
\end{lstlisting}

Ordinare le strutture indicate secondo la sequenza con cui verranno eseguite
Risposta:
\begin{enumerate}
	\item statico
	\item Costruttore Foo
	\item Inizializzatore
	\item Costruttore Bar
\end{enumerate}

Nelle Reactive Èxtensions, quali di queste operazioni non è necessario (o possibile) specificare per elaborare gli oggetti emessi da un observable:

Scegli una o più alternative:

\begin{itemize}
	\item Il comportamento alla ricezione di un oggetto.
	\item ll numero di oggetti che l'observable è autorizzato ad inviare. 
		\checkmark
	\item Il comportamento alla richiesta di separazione di uno stream 
		parallelo. \checkmark
	\item Il comportamento al termine dello stream di oggetti.
	\item Il comportamento alla ricezione di un errore.
\end{itemize}

Implementare un programma di rete usando l'astrazione dei "Channels" della libreria standard di Java permette di non occuparsi di molti dettagli riguardanti
l'interazione con il mezzo di comunicazione, ma:

Scegli un'alternativa: 

\begin{itemize}
	\item È necessario ristrutturare il nostro codice riorganizzando in metodi che vengono
	\item richiamati all'avvenire di specifici eventi di I/O. \checkmark
	\item È sufficiente sostituire il codice che gestisce la ricezione di un pacchetto di dati.
	\item È necessario riscrivere le parti che interagiscono con il mezzo di comunicazione per gestire in modo diverso la concorrenza.
	\item È sufficiente sostituire il codice che gestisce una nuova connessione entrante.
\end{itemize}

Nella implementazione degli Stream della libreria standard, che vantaggio si ottiene dal fatto che la API consente di costruire la catena di elaborazione separatamente
dalla sua esecuzione?

Scegli un'alternativa:

\begin{itemize}
	\item L'implementazione può analizzare le operazione della catena, e decidere se eseguirle parallelamente o in serie.
	\item L'implementazione può sempre sapere se dovrà eseguire un numero finito o meno di elaborazioni in funzione unicamente delle operazioni intermedie.
	\item L'implementazione può analizzare le operazioni della catena, e 
		prendere decisioni su come applicarle in funzione delle loro 
		caratteristiche. \checkmark
\end{itemize}

////////////////////////////////////////////////////////////////

Come molti altri linguaggi Object-Oriented, Java ha a disposizione un meccanismo di ereditarietà per estendere classi esistenti senza doverle modificare. L'ereditarietà
in Java ha le seguenti caratteristiche:

Scegli una o più alternative:

\begin{itemize}
	\item A causa dell'introduzione dei default methods, è possibile causare un 
		Diamond Problem. \checkmark
	\item Il Diamond Problem è impossibile per costruzione.
	\item Una classe può ereditare da una sola altra classe. \checkmark
	\item Una interfaccia può ereditare da un'altra interfaccia. \checkmark
	\item Una interfaccia può implementare una sola altra interfaccia.
	\item Una classe può implementare più interfacce. \checkmark
\end{itemize}

La fallacia "Network is homogeneus" è stata aggiunta alle prime sette da Gosling, proprio in seguito alle prime esperienze con Java. Oggi, la sua rilevanza:

Scegli un'alternativa: 

\begin{itemize}
	\item È ancora maggiore, perché le tipologie e le caratteristiche delle reti 
		sono sempre più varie. \checkmark
	\item È tutto sommato un problema risolto dalla diffusione dei protocolli 
		più recenti.
	\item Non è più rilevante dopo la diffusione delle connessioni wireless.
	\item È ancora rilevante, ma si tratta ormai di un problema ormai sotto 
		controllo.
\end{itemize}

Lo scopo delle Reactive Extensions è:

Scegli un'alternativa: 

\begin{itemize}
	\item Fornire un insieme di componenti per l'elaborazione distribuita di stream di valori.
	\item Fornire una semantica per definire elaborazioni asincrone di sequenze di oggetti. \checkmark
	\item Fornire un modello di esecuzione di elaborazioni parallele di i di oggetti.
	\item Fornire una API per definire elaborazioni di sequenze di oggetti.
\end{itemize}


Quando si dice che il compilatore Java ha delle capacità di Type Inference si intende che:

Scegli un'alternativa: 

\begin{itemize}
\item È in grado di calcolare la corretta indentazione del codice e correggerla.
\item È in grado di indicare se il grafo dell'ereditarietà genera un diamond problem.
\item È in grado di trasformare un tipo în un'altro senza indicazioni esterne.
\item È in grado di dedurre il tipo di alcune espressioni senza che sia
	necessario indicarlo esplicitamente. \checkmark
\end{itemize}


Quando si dice che la parola chiave syncronized introduce una relazione di happens-before nel codice, si intende che:

Scegli un'alternativa: 
\begin{itemize}

	\item Il compilatore viene istruito a garantire che il codice sorvegliato
		dalla parola chiave syncronized venga effettivamente eseguito dopo il
		codice che lo precede, indipendentemente da quanti Thread lo
		attraversino.
	\item Il compilatore viene istruito a garantire che il codice sorvegliato
		dalla parola chiave syncronized venga eseguito contemporaneamente al
		codice che viene collegato dall'argomento dell'espressione.
	\item Il compilatore viene istruito a garantire che il codice sorvegliato
		dalla parola chiave syncronized venga allineato al trasferimento di dati
		fra la memoria principale e la cache del microprocessore.
	\item Il compilatore viene istruito a garantire che il codice sorvegliato
		dalla parola chiave syncronized venga effettivamente eseguito prima del
		codice che lo segue, e da un solo Thread alla volta. \checkmark
\end{itemize}

È importante gestire velocemente l'accettazione di un pacchetto da una DatagramSocket perché:

Scegli un'alternativa: 
\begin{itemize}

	\item Se non c'è un thread in attesa su DatagramSocket:receive(), nessun
		pacchetto viene ricevuto.
	\item Se non c'è un thread in attesa della ricezione di un pacchetto, questo
		viene scartato. 
	\item Se c'è un thread in attesa su DatagramSocket::receive(), gli invii
		sono bloccati. 
	\item I pacchetti ricevuti vengono conservati in buffer limitati; se si
		riempiono, i messaggi successivi sono scartati. \checkmark
\end{itemize}


I membri di una interfaccia Java:

Scegli un'alternativa: 
\begin{itemize}
	\item Nessuno di essi deve specificare una implementazione.
	\item Sono immutabili.
	\item Sono tutti pubblici, senza necessità di indicarlo. \checkmark
	\item Sono indipendenti dal tipo di appartenenza.
\end{itemize}

Perché nel linguaggio Java si è deciso di introdurre i metodi di default nelle Interfacce?

Scegli un'alternativa: \begin{itemize}

	\item Per inseguire una feature richiesta dal mercato.
	\item Per rendere più difficile modificare l'implementazione delle
		interfacce in modi non previsti. 
	\item Per evitare una possibilità di realizzare un diamond problem.
	\item poter estendere delle interfacce consolidate senza richiedere
		l'aggiornamento del codice esistente. \checkmark
\end{itemize}

Una operatore short-circuiting all'intemo di una catena di elaborazione di uno Stream può:

Scegli un'alternativa: \begin{itemize}

	\item Ottenere uno Stream infinito da una funzione di trasformazione.
	\item Produrre il risultato prima che lo Stream sia stato interamente
		consumato. \checkmark
	\item Cambiare l'ordine degli elementi dello Stream.
	\item Rendere seriale l'elaborazione di uno Stream parallelo.
\end{itemize}


Selezionare quali delle seguenti sono condizioni di Coffman necessarie per l'instaurarsi di un deadlock.

Scegli una 0 più alternative:
\begin{itemize}

	\item Ordinamento dell'esecuzione
	\item Possesso e attesa \checkmark
	\item Salvataggio del contesto
	\item Temporizzazione dell'accesso
	\item Mutua Esclusione \checkmark 
	\item Risorse non riassegnabili \checkmark
	\item Attesa circolare \checkmark
\end{itemize}

Usando i Reactive Stream, la gestione più granulare della composizione della pipeline di elaborazione dello stream permette di:

Scegli un'alternativa: 
\begin{itemize}
	\item Scegliere algoritmi di suddivisione del lavoro più efficienti di quelli della libreria standard, perché più facili da aggiornare.
	\item Isolare la parte di pipeline che si desidera sia resa parallela; gli
		Stream della libreria standard sono 0 completamente paralleli, o
		completamente seriali. \checkmark
	\item Distribuire i singoli componenti dell'elaborazione su più nodi,
		indicando su quali nodi aumentare il parallelismo e su quali accumulare
		i risultati da elaborare serialmente.
	\item Ridurre la latenza dell'elaborazione dei vari componenti decidendo
		quante risorse dedicare a ciascuno di essi. 
\end{itemize}

Se in un sistema distribuito i nodi non trovano un consenso sullo stato del sistema, può accadere che:

Scegli un'alternativa: \begin{itemize}
	\item Le risposte del sistema siano molteplici e conflittuali perché raccolgono i dati da più nodi.
	\item Le risposte del sistema siano inefficienti perché le differenti versioni dello stato si accavallano in una pace condition.
	\item Le risposte del sistema siano incoerenti e dipendano da quale nodo viene contattato. \checkmark
	\item Le risposte del sistema non siano disponibili in quanto gli stati differenti si annullano.
\end{itemize}

Indicare quali fra le seguenti sono problematiche che rendono la serializzazione un processo complesso, che richiede molte attenzioni:

Scegli una o più alternative
\begin{itemize}
	\item \checkmark Il processo di serializzazione deve essere efficiente nel tempo e nello spazio impiegati.
	\item \checkmark Un oggetto può contenere altri oggetti, che potrebbbero non essere rappresentabili.
	\item È necessario disporre di un metodo per riordinare le parti del messaggio ricevute.
	\item \checkmark È necessario disporre di un metodo per verificare integrità e affidabilità dei dati ricevuti.
	\item \checkmark Mittente e ricevente possono avere versioni diverse dell'oggetto serializzato.
	\item È necessario disporre di un protocollo che delimiti correttamente le varie parti del messaggio.
\end{itemize}

Quando di un sistema reattivo si indicano le sue qualità come Responsive, Resilient, Elastic, Message-Oriented, con la qualità "Message-Oriented" sî intende:

Scegli un'alternativa: 
\begin{itemize}
	\item Il sistema risponde proporzionalmente alla quantità di richieste in ingresso.
	\item \checkmark L'unica primitiva di comunicazione fra i componenti è il messaggio asincrono. 
	\item Il sistema è disponibile anche in caso di guasto parziale.
	\item Il sistema fornisce delle funzionalità di coda di messaggi distribuita.
\end{itemize}

Nell'astrazione delle Reactive Extensions, un subject può:

Scegli un'alternativa: 

\begin{itemize}
	\item Osservare uno Stream esaminando solo alcuni elementi.
	\item Osservare altri subject e observable alterando la struttura dello stream fra di loro.
	\item \checkmark Osservare diversi observable, e comportarsi da observable esso stesso, modificando la struttura dell'elaborazione dello stream.
	\item Osservare uno Stream in modalità parallela.
\end{itemize}

Il compilatore Java può riordinare le istruzioni di un blocco di codice in seguito a considerazioni di ottimizzazione ed efficienza. Per imporre un ordinamento preciso è
possibile:

Scegli un'alternativa: 
\begin{itemize}
	\item \checkmark Usare la parola chiave syncronized per introdurre un ordinamento specifico, con una relazione di happens-before.
	\item Usare la parola chiave final per prevenire modifiche di questo tipo durante la compilazione.
	\item Usare la parola chiave volatile per segnalare un blocco di codice che non va riordinato.
	\item Usare la parola chiave strictfp per richiedere una semantica precisa delle istruzioni riordinate.
\end{itemize}

Un Thread esce dallo stato blocked quando:

Scegli un'alternativa:

\begin{itemize}
	\item Ottiene il lock che stava aspettando o viene interrotto.
	\item Viene interrotto (e solo in questo caso).
	\item Trascorre esattamente il tempo impostato (e solo în questo caso).
	\item \checkmark Ottiene la risorsa di sistema che aveva richiesto.
\end{itemize}

Quale dei seguenti non è uno Stream Flag, cioè una caratteristica che uno Stream può dichiarare ed uno operatore (intermedio o terminale) utilizzare per organizzare
l'esecuzione:

Scegli un'alternativa: 

\begin{itemize}
	\item SUBSIZED - lo stream può essere diviso in partizioni di dimensione nota.
	\item \checkmark UNTYPED - non è noto a priori il tipo degli elementi.
	\item CONCURRENT - lo stream supporta l'elaborazione parallela.
	\item NONNULL - tutti gli elementi sono diversi da null.
\end{itemize}

Che tipo di rischi devono essere considerati nella scelta e nell'adozione di un framework per la costruzione di applicazioni distribuite?

Scegli una o più alternative:

\begin{itemize}
	\item \checkmark Errori operativi dovuti a bachi nel codice del framework. 
	\item Indisponibilità di assistenza remota nella risoluzione degli errori applicativi.
	\item \checkmark Direzione di sviluppo non allineata con le esigenze dell'evoluzione dell'applicazione.
	\item Errori operativi dovuti a configurazioni di default insicure o difficili da capire.
	\item \checkmark Casi d'uso particolari non coperti dalle funzionalità del framework. 
	\item Difficoltà a rimuovere gli errori dal proprio codice una volta introdotto il framework.
\end{itemize}

Quale di queste caratteristiche è propria della sintassi switch-case come espressione:

Scegli un'alternativa: 
\begin{itemize}
	\item I risultati devono essere tutti valori della stessa interfaccia.
	\item Ogni caso deve produrre un risultato diverso.
	\item È possibile il fall-through da un caso all'altro.
	\item \checkmark L'elenco delle opzioni deve essere esaustivo. 
\end{itemize}


Il modello dei Thread permette ad un Processo di organizzare più linee di esecuzione al suo interno incorrendo in una minore penalità di cambiamento del contesto
durante l'esecuzione. Tuttavia, si ritrova a dover gestire:

Scegli un'alternativa: 

\begin{itemize}
	\item \checkmark L'accesso e la condivisione delle risorse
	\item La ricezione degli eventi di rete
	\item L'invio dei byte alle periferiche di I/O
	\item L'organizzazione della memoria esterna
\end{itemize}

Quali dei seguenti possono essere indicati come vantaggi dell'uso dei Datagram:

Scegli una o più alternative:
\begin{itemize}
	\item La consegna di un Datagram non è legata ad una specifica porta.
	\item \checkmark Un singolo Datagram può essere inviato a molti indirizzi con una sola istruzione.
	\item \checkmark Il singolo Datagram è isolato, quindi non è necessario introdurre nel protocollo dei separatori fra messaggi diver
	\item La consegna di un singolo Datagram ha una latenza inferiore all'invio su Socket.
\end{itemize}

Quali vantaggi si cercano nel distribuire lo stato di un sistema su più nodi:

Scegli una 0 più alternative:
\begin{itemize}
	\item Elaborazione più rapida delle richieste distribuite a più nodi.
	\item \checkmark possibilità di gestire uno stato più grande della capacità di una singola macchina.
	\item Maggiore sicurezza dei dati gestiti dal sistema di consenso.
	\item \checkmark Accesso più rapido da località differenti. 
\end{itemize}

Le classi del package java.concurrent.atomic

Scegli un'alternativa: 
\begin{itemize}
	\item Sono particolarmente efficienti in caso di modifica concorrente del dato che rappresentano perché usano nel modo migliore i lock.
	\item \checkmark Sono particolarmente efficienti in caso di modifica concorrente del dato che rappresentano perché usano (se disponibili) delle funzionalità fornite direttamente
	\item dall'hardware. 
	\item Non sono adatte nel caso di modifica concorrente perché permettono di leggere un dato che in realtà è già stato modificato.
	\item Non sono adatte nel caso di modifica concorrente perché permettono una sola modifica alla volta.
\end{itemize}

Nel linguaggio Java, una variabile final:

Scegli un'alternativa: 

\begin{itemize}
	\item Può contenere un valore di un solo tipo.
	\item Richiama un metodo al momento della cancellazione.
	\item Richiama un metodo quando viene modificata.
	\item \checkmark Deve essere inizializzata contestualmente alla definizione, ed il suo valore non può essere cambiato.
\end{itemize}

Una variabile di tipo threadLocal$< $T$ >$:

Scegli un'alternativa: 
\begin{itemize}
	\item \checkmark Possiede un valore differente per ogni Thread che vi accede.
	\item Permette ad più Thread di accedere rapidamente al valore che contiene.
	\item Un solo Thread per volta può accedere al valore contenuto.
\end{itemize}

Più Thread possono accedere allo stesso valore senza interferire fra loro.

Una classe Java dichiarata abstract è visibile:

Scegli un'alternativa: 
\begin{itemize}
	\item Solo dalle classe che la estendono.
	\item Da tutte le classi dello stesso package.
	\item \checkmark abstract non è un modificatore di visibilità.
	\item Da qualsiasi classe.
\end{itemize}

Quale delle seguenti affermazioni riguardante le Lambda Expression è vera:

\begin{itemize}
	\item Rendono Java un linguaggio funzionale perché possono essere passate come parametri diuna chiamata ad un metodo.
	\item \checkmark Non rendono Java un linguaggio funzionale perché non sono una entità del linguaggio, masolo una convenienza sintattica risolta dal compilatore.
	\item Non rendono Java un linguaggio funzionale perché non sono facilmente componibili.
	\item Rendono Java un linguaggio funzionale perché permettono di astrarre sul comportamentodi un metodo chiamato.
\end{itemize}

Nelle Reactive Extensions, quali di queste operazioni nonè necessario (o possibile) specificare per elaborare glioggetti emessi da un Observable:

\begin{itemize}
	\item Il comportamento alla ricezione di un oggetto.
	\item Il comportamento al termine dello stream di oggetti.
	\item \checkmark Il numero di oggetti che l'Observable è autorizzato ad inviare.
	\item \checkmark Il comportamento alla richiesta di separazione di uno stream parallelo.
	\item Il comportamento alla ricezione di un errore.
\end{itemize}

La fallacia "Latency is zero" è ancora rilevante perché:
\begin{itemize}
	\item L'aumento dei nodi della rete ha compensato il miglioramento tecnologico, mantenendo ilproblema sostanzialmente uguale.
	\item Le tecnologie di comunicazione hanno eliminato il problema presente in passato, ma leesigenze di concorrenza l'hanno reintrodotto in altra forma.
	\item \checkmark Dipende da una grandezza fisica
\end{itemize}

Che tipo di vantaggi si possono avere dall'adottare un framework per la costruzioni di applicazioni distribuite?
\begin{itemize}
	\item \checkmark Maggiore sicurezza perché i dettagli sono gestiti da persone più competenti.
	\item \checkmark Aggiornamento continuo che apporta benefici a tutte le parti dell'applicazione, in modoquasi automatico.
	\item Estrema efficienza nello sfruttare le peculiarità dell'hardware a disposizione.
	\item Assistenza remota nella risoluzione degli errori applicativi.
	\item \checkmark Facilità di realizzazione perché i dettagli dei protocolli di comunicazione sono nascosti da APIdi livello più elevato.
	\item Aggiornamento continuo che non richiede intervento da parte dello sviluppatore.
	\item \checkmark Facilità di realizzazione perché le parti più strutturali sono giù implementate.
\end{itemize}

L'interfaccia Collector permette di eseguire la riduzionead un risultato di uno Stream parallelo in modo piùefficiente perché:
\begin{itemize}
	\item Perché non necessita di sapere la lunghezza dello Stream.
	\item \checkmark Perchè gestisce un accumulatore mutabile, che riduce la pressione sulla Garbage Collection.
	\item Perché combina i risultati intermedi più velocemente.
	\item Perché mantiene il parallelismo dello Stream.
\end{itemize}

Un Thread esce dallo stato timed waiting quando:

\begin{itemize}
\item Trascorre esattamente il tempo impostato (e solo in questo caso).
\item Ottiene il lock che stava aspettando o viene interrotto.
\item \checkmark Ottiene il lock che stava aspettando, oppure viene interrotto o trascorre il timeoutimpostato.
\item Viene interrotto (e solo in questo caso)
\end{itemize}

\section{Appello 2}

In reazione alla ricezione di un messaggio, un attore può:

\begin{itemize}
	\item \checkmark Creare nuovi attori.
	\item \checkmark Modificare il suo stato interno.
	\item \checkmark Inviare messaggi ad attori di cui ha un riferimento.
	\item Modificare lo stato di un attore di cui ha un riferimento.
	\item Inviare un messaggio ad un attore di un altro nodo del sistema.
	\item Eliminare un attore di cui ha un riferimento.
	\item \checkmark Modificare il suo comportamento per la ricezione dei prossimi messaggi
\end{itemize}

Implementare un programma di rete usando l'astrazione dei Channels della libreria standard di Java permette di nonoccuparsi di molti dettagli riguardanti l'interazione con ilmezzo di comunicazione, ma:

\begin{itemize}
	\item È sufficiente sostituire il codice che gestisce la ricezione di un pacchetto di dati.
	\item È necessario riscrivere le parti che interagiscono con il mezzo di comunicazione per gestirein modo diverso la concorrenza.
	\item È sufficiente sostituire il codice che gestisce una nuova connessione entrante.
	\item \checkmark È necessario ristrutturare il nostro codice riorganizzando in metodi che vengono richiamatiall'avvenire di specifici eventi di I/O
\end{itemize}

Quale delle seguenti affermazioni riguardo ai rapporti fra Processi, Thread e Fiber è vera:
\begin{itemize}
	\item \checkmark Le risorse dei Processi sono controllate dal Sistema Operativo, mentre all'interno deiProcessi i Thread devono direttamente controllare il loro accesso. Le Fiber rendono esplicitala concorrenza con lo scopo di essere ancora più leggere dei Thread.
	\item I Processi sono raggruppamenti logici di risorse che nei Thread vengono associati a risorsefisiche. Le Fiber sono un miglioramento dei Thread.
	\item Una volta allocata una risorsa, non può essere sottratta ad un Processo. Ad un Thread invece può essere sottrratta, mettendolo in stato waiting. Le Fiber rendono la gestione dellaconcorrenza più esplicita.
	\item I Processi evitano il deadlock attraverso l'ordinamento delle priorità. I Thread invece nonsono ordinati e devono essere manualmente controllati per evitare conflitti nella gestionedelle risorse. Le Fiber sono una evoluzione più efficiente dei Thread.
\end{itemize}

Quale delle seguenti frasi è falsa per una struttura dati non Thread-Safe in caso di accesso concorrente:
\begin{itemize}
	\item Può dare un risultato errato o venirsi a trovare in uno stato inconsistente
	\item Può lanciare un'eccezione per segnalare un accesso non consentito o pericoloso
	\item \checkmark È meno costosa in termini di cicli di CPU che nel caso di accesso esclusivo.
	\item È più performante nel caso generale
\end{itemize}

È importante gestire velocemente l'accettazione di una nuova connessione su di un ServerSocket perché:

\begin{itemize}
	\item Finché non c'è un thread che attende in ServerSocket::accept(), le operazioni di scrittura sulSocket non riprendono.
	\item \checkmark Finché non c'è un thread che attende in ServerSocket::accept(), le nuove richieste diconnessione si accodano su di un buffer del sistema operativo che può avere una lunghezza molto limitata.
	\item Finché non c'è un thread che attende in ServerSocket::accept(), le operazioni di lettura sulSocket non riprendono.
	\item Finché non c'è un thread che attende in ServerSocket::accept(), i buffer di invio e ricezionedati del sistema operativo non sono sorvegliati e potrebbero riempirsi
\end{itemize}

Un oggetto Future rappresenta:
\begin{itemize}

	\item \checkmark Un calcolo che potrebbe produrre un risultato dopo un certo tempo.
	\item Una generica esecuzione concorrente.
	\item Il risultato di un calcolo parallelo terminato correttamente.
	\item Un calcolo concorrente terminato in modo errato
\end{itemize}

Associare ad ogni condizione di Coffmann una strategia utile per rimuoverla.
   Una delle strategie indicate non è rilevante.

\begin{itemize}
	\item \checkmark Attesa circolare → Ordinamento dell'acquisizione,
	\item \checkmark (non rilevante) → Esecuzione fuori ordine,
	\item \checkmark Mutua Esclusione →  Algoritmi lock-free,
	\item \checkmark Risorse non riassegnabili→  Pre-emption,
	\item \checkmark Possesso e attesa → Assegnazione delle risorse transazionale
\end{itemize}

La comunicazione su Socket ha diversi vantaggi, ma il fatto che i dati vengano presentati come uno stream di byte ha i seguenti svantaggi:

\begin{itemize}
	\item \checkmark Deve essere definito un protocollo con cui i due lati della comunicazione riconoscono l'inizio e la fine dei messaggi.
	\item Nel caso di comunicazione fra più di due parti sullo stesso socket, il protocollo deve permettere l'identificazione del mittente di ogni messaggio.
	\item \checkmark Le due parti devono concordare in qualche modo l'encoding delle stringhe all'interno del protocollo di comunicazione.
	\item Le due parti della comunicazione devono inviare i propri dati il più velocemente possibile per diminuire la latenza della comunicazione
\end{itemize}

In questo codice di esempio:

\begin{lstlisting}[language=Java]
try(DatagramSocketsocket=newDatagramSocket(8080){
    byte[] buf=newbyte[16];
    DatagramPacketpacket=newDatagramPacket(buf, 16);// 
    //A
    Stringinput=newString(packet.getData(), 0, packet.getLength());
    System.out.println(input);
    // B
}
\end{lstlisting}

in che punto va inserita la chiusura della risorsa DatagramSocket:
\begin{itemize}
	\item In un blocco finally da aggiungere in coda al blocco try.
	\item Nel punto A.
	\item Nel punto B.
	\item \checkmark Non è necessaria
\end{itemize}

Associare ciascuna struttura di gestione della concorrenza al suo ambito di applicazione:

\begin{itemize}
	\item Semaphore | Gestione di un insieme omogeneo di risorse,
	\item Lock Gestione | esplicita, senza legami sintattic, del blocco e dello sblocco della sezione critica.
	\item syncronized | Gestione della concorrenza tramite la struttura sintattica del codice.
	\item condition | Gestione dell'accesso alla stessa sezione critica in condizioni di blocco e/o sblocco dilferenti. 
	\item object: :Wait() | Gestione esplicita dell'accesso ad un singolo oggetto. six
\end{itemize}

Quali di queste caratteristiche sono richieste per parlare di programmazione concorrente:

Scegli una o più alternative:

\begin{itemize}
	\item Comunicazione tramite messaggi
	\item \checkmark Processi separati
	\item Uniformità tecnologica fra i processi
	\item \checkmark Coesistenza sullo stesso nodo di calcolo 
	\item \checkmark Condivisione di risorse
	\item \checkmark Esecuzione contemporanea 
\end{itemize}

L'astrazione channel della libreria standard di Java permette di non occuparsi di molti dettagli riguardanti l'interazione con il mezzo di comunicazione. 1 vari metodi che
l'astrazione richiede di implementare sono accomunati dall'uso di un parametro attachment. Il suo scopo è:

Scegli un'alternativa: 

\begin{itemize}
	\item Rendere accessibile in ogni momento il canale sottostante la comunicazione.
	\item \checkmark Trasportare in sicurezza il contesto della conversazione, fra metodi che saranno richiamati da thread differenti.
	\item Distribuire fra i vari metodi i dati globali del programma.
	\item Fornire il dato letto dal canale di comunicazione.
\end{itemize}

Perché l'elaborazione dia un risultato corretto, è richiesto che le operazioni interne siano:

Scegli una o più alternative:

\begin{itemize}
	\item Prive dî uno stato interno.
	\item Implementate da oggetti diversi.
	\item Prive di allocazioni di nuovi oggetti.
	\item \checkmark Non invasive: non devono modificare o interferire con gli elementi dello Stream.
\end{itemize}

Come molti altri linguaggi Object-Oriented, Java ha a disposizione un meccanismo di ereditarietà per estendere classi esistenti senza doverle modificare. L'ereditarietà in
Java ha le seguenti caratteristiche:

Scegli una o più alternative:

\begin{itemize}
	\item \checkmark A causa dell'introduzione dei default methods, è possibile causare un Diamond Problem.
	\item Una interfaccia può implementare una sola altra interfaccia.
	\item \checkmark Una classe può implementare più interfacce. 
	\item Il Diamond Problem è impossibile per costruzione.
	\item \checkmark Una classe può ereditare da una sola altra classe.
	\item \checkmark Una interfaccia può ereditare da un'altra interfaccia.
\end{itemize}

La fallacia "Bandwidth is infinite":

Scegli un'alternativa: 

\begin{itemize}
	\item \checkmark È ancora rilevante perché anche se è cresciuta la banda mediamente disponibile, è anche molto aumentata la quantità di dati trasmessi.
	\item È ancora rilevante in quanto dipendente da limiti fisici.
	\item Non è più rilevante in quanto anche in mobilità la banda disponibile è ubiquitaria ed elevata.
\end{itemize}

Quale delle seguenti affermazioni è corretta riguardo allo stato di un Attore:

Scegli un'alternativa: 

\begin{itemize}
	\item Lo stato di un Attore viene modificato da ogni messaggio ricevuto.
	\item Lo stato di un Attore può essere modificato solo dall'Attore stesso o dall'Attore che lo ha creato.
	\item \checkmark Lostato di un Attore può essere modificato da più messaggi contemporaneamente, e va gestito con variabili thread-safe.
	\item Lo stato di un Attore è privato, e può essere solo modificato alla ricezione di un messaggio.
\end{itemize}

Nel linguaggio Java, un metodo final:

Scegli un'alternativa: 
\begin{itemize}
	\item Il suo valore di ritomo non può essere modificato.
	\item Deve essere reimplementato da una classe derivata.
	\item Viene richiamato al momento della cancellazione dell'oggetto.
	\item \checkmark Non può essere reimplementato da una classe derivata.
\end{itemize}

La parola chiave volatile fornisce un particolare tipo di garanzie di concorrenza. È necessaria a causa dî:

Scegli un'alternativa: 
\begin{itemize}
	\item Effetti quantistici di interferenza fra celle vicine di memoria.
	\item \checkmark Peculiarità della struttura della memoria di sistemi multiprocessore.
	\item Gestione della permanenza dei dati in seguito al riavvio della JVM.
	\item Effetti termici delle memorie a velocità superiori ad una certa soglia.
\end{itemize}


Uno stream rappresenta una sequenza di elementi, potenzialmente infinita. L'obiettivo di questa astrazione è:

Scegli un'alternativa: 
\begin{itemize}
	\item \checkmark Permettere di descrivere l'elaborazione in termini i sugli i, e non dell delliterazione.
	\item Fornire l'API per attraversare più rapidamente la collezione.
	\item Uniformare l'accesso a più collezioni di struttura differente.
	\item Permettere di controllare più finemente l'avanzamento dell'ierazione.
\end{itemize}


\section{Appello 3} 

In questo codice di esempio:

\begin{lstlisting}
	try(ServerSocket serverSocket= new ServerSocket(8030);
	Socket socket serverSocket.accept();
	Printuiriter out = new PrintWriter(socket.getOutputStream(), true);
	An = new Buff Inpi den(socket..getInpi 05) {
	String inputtine;
	while ((inputline = in.readLine()) != null) {
	System.out.printIn("Received: " + inputlLine);
	out.printin(*Hello * + inputline);
}
\end{lstlisting}

Una eccezione lanciata dall'oggetto out ha come effetto:

Scegli un'alternativa: 
\begin{itemize}
	\item La chiusura della sola risorsa in.
	\item La chiusura delle risorse serverSocket e socket, ma non di in.
	\item \checkmark La chiusura di tutte le risorse e l'uscita dal blocco.
	\item L'uscita dal blocco con perdita delle risorse allocate.
\end{itemize}

Quali dei seguenti possono essere indicati come vantaggi dell'uso dell'oggetto Socket per la comunicazione:

Scegli una o più alternative:

\begin{itemize}
	\item La connessione con un Socket non è legata ad una specifica porta del nodo connesso.
	\item \checkmark La comunicazione può essere bidirezionale.
	\item \checkmark L'orientamento alla connessione del Socket permette di trasferire in modo affidabile quantità di dati rilevanti.
	\item l'buffera disposizione per le connessioni su Socket sono più ampi di quelli per i Datagram.
\end{itemize}

Quali vantaggi si vogliono ottenere nel distribuire lo stato di un sistema su più nodi:

Scegli una o più alternative:

\begin{itemize}
	\item Suddivisione del lavoro fra più nodi per una elaborazione più rapida delle richieste.
	\item \checkmark Affidabilità rispetto al guasto fisico di uno 0 più nodi.
	\item Maggiore sicurezza dei dati gestiti dal sistema di consenso.
	\item \checkmark Gestione di una mole di dati più grande della capacità di una singola macchina. 
\end{itemize}

Un Thread può trovarsi in diversi stati di attesa: waiting, timed waiting, blockes. In cosa si distinguono?

Scegli un'alternativa: 

\begin{itemize}
	\item Dipendono da questioni tecnologiche mediate dalla JVM.
	\item Dipendono dalla chiamata di libreria standard usata per richiedere una risorsa.
	\item Sono gestiti da strutture sintattiche differenti.
	\item \checkmark È diverso il motivo dell'attesa, la sua durata ed il modo in cui si esce dallo stato.
\end{itemize}

Una classe Java dichiarata senza modificatori di visibilità:

Scegli un'alternativa: 

\begin{itemize}
	\item E visibile da ogni classe del sistema.
	\item Un modificatore di visibilità è obbligatorio.
	\item \checkmark Da ogni classe dello stesso package.
	\item Solo dalle classe che la estendono.
\end{itemize}
\end{document}
