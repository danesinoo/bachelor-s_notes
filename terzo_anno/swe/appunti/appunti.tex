\documentclass[12pt]{article}
\newcommand{\template}{../../../template}
\usepackage{\template/packages}

\newcommand{\titolo}{Appunti sui Design Pattern}
\newcommand{\autore}{Rosso Carlo}
\newcommand{\data}{A.A. 2023/2024}
\newcommand{\corso}{Ingegneria del Software}

\input{\template/copertina}

\begin{document}
\copertina
\tableofcontents
\newpage

\section{AbstractFactory}

Applicabilità:
\begin{enumerate}
	\item Un sistema deve essere indipendente da come i suoi prodotti sono
	      creati, composti e rappresentati.

	\item Un sistema deve essere configurato con una famiglia di prodotti
	      multipli.

	\item Una famiglia di prodotti correlati è progettata per essere utilizzata
	      insieme e si desidera far rispettare questa vincolo.

	\item Si vuole fornire una libreria di classi per la creazione di prodotti,
	      ma si vuole nascondere le implementazioni concrete.
\end{enumerate}

\section{Builder}

Applicabilità:
\begin{enumerate}
	\item L'algoritmo per la creazione di un oggetto complesso deve essere
	      separato e indipendente dalle parti che compongono l'oggetto e da come
	      vengono assemblate.

	\item Il processo di costruzione deve permettere diverse rappresentazioni
	      dell'oggetto da costruire.
\end{enumerate}

\section{Adapter}

Applicabilità:
\begin{enumerate}
	\item Si desidera utilizzare una classe esistente e la sua interfaccia non
	      corrisponde a quella che si desidera.

	\item Si desidera creare una classe riusabile che collabora con classi non
	      correlate o non previste, cioè classi che non necessariamente hanno
	      interfacce compatibili.

	\item (solo per oggetti adapter) Si desidera utilizzare diverse sottoclassi
	      esistenti, ma è impraticabile adattare la loro interfaccia per ogni
	      sottoclasse. Un adapter può adattare l'interfaccia della sua classe
	      progenitrice.
\end{enumerate}

\section{Decorator}

Applicabilità:
\begin{enumerate}
	\item Aggiungere responsabilità a singoli oggetti dinamicamente e in modo
	      trasparente, cioè senza coinvolegere altri oggetti.

	\item Si vuole poter rimuovere responsabilità aggiunte.

	\item Quando l'ereditarietà è inapplicabile, ad esempio perché è
	      staticamente definita e non può essere modificata o perché si
	      desidera evitare la creazione di sottoclassi per ogni nuova
	      responsabilità, che potrebbe portare a un'esplosione di classi.
\end{enumerate}

\section{Facade}

Applicabilità:
\begin{enumerate}
	\item Si desidera fornire un'interfaccia unificata a un insieme di interfacce
	      in un sottosistema. Facade definisce un'interfaccia di livello più
	      alto che rende il sottosistema più facile da usare.

	\item Si desidera disaccoppiare un sottosistema da suoi clienti e da altri
	      sottosistemi, rendendo il sottosistema più indipendente e
	      scalabile.

	\item Si desidera raggruppare un insieme di interfacce complesse in un'unica
	      interfaccia più semplice da usare.

	\item Si vogliono organizzare i sottosistemi in una struttura a livelli. Il
	      pattern Facade definisce un'interfaccia per ciascun livello del
	      sottosistema.
\end{enumerate}

\section{Proxy}

Applicabilità:
\begin{enumerate}
	\item \textbf{Accesso remoto}: un proxy remoto fornisce un'interfaccia
	      locale per un oggetto in un sistema remoto.

	\item \textbf{Proxy virtuale}: un proxy può creare un oggetto complesso solo
	      quando viene richiesto.

	\item \textbf{Proxy di protezione}: un proxy controlla l'accesso all'oggetto
	      originale. Ad esempio, un proxy potrebbe verificare che il chiamante
	      abbia i permessi necessari per eseguire un'operazione, oppure
	      implementa un semaforo per controllare l'accesso concorrente.

	\item \textbf{Riferimento intelligente}: un proxy può gestire il ciclo di
	      vita di un oggetto originale. Ad esempio, un proxy può tenere il conto
	      dei riferimenti ad un oggetto e lo elimina quando il conto raggiunge
	      zero.
\end{enumerate}

\section{Command}

Applicabilità:
\begin{enumerate}
	\item Parametrizzare gli oggetti rispetto ad un'operazione da eseguire.

	\item Definire, eseguire e accodare richieste in un oggetto. In particolare
	      permette di eseguire operazioni indipendenti in modo asincrono.

	\item Supportare operazioni annullabili. Il metodo \texttt{execute} può
	      memorizzare lo stato necessario per annullare i suoi effetti nel
	      comando stesso. I comandi che sono stati eseguiti tramite
	      \texttt{execute} devono essere memorizzati in uno storico. In questo
	      modo è possibile annullare i comandi eseguiti.

	\item Organizzare un sistema in operazioni ad alto livello costruite su
	      operazioni a basso livello. Per esempio, il Command pattern è una
	      soluzione per la modellazione di transazioni.
\end{enumerate}

\section{Iterator}

Applicabilità:
\begin{enumerate}
	\item Accedere agli elementi di un oggetto aggregato senza esporre la sua
	      rappresentazione sottostante.

	\item Supportare più attraversamenti in modo uniforme.

	\item Fornire un'interfaccia uniforme per attraversare diversi tipi di
	      aggregati.
\end{enumerate}

\section{Observer}

Applicabilità:
\begin{enumerate}
	\item Un'astrazione presenta due aspetti, di cui uno dipende dall'altro.
	      Incapsulando questi aspetti in oggetti separati, è possibile riusarli
	      indipendentemente.

	\item Un cambiamento di stato in un oggetto richiede modifiche in altri
	      oggetti dipendenti, ma non si conosce il numero di oggetti dipendenti.

	\item Un oggetto deve notificare altri oggetti senza fare ipotesi su chi
	      siano questi oggetti. In altre parole, si vuole mantenere un alto
	      livello di disaccoppiamento.
\end{enumerate}

\section{Strategy}

Applicabilità:
\begin{enumerate}
	\item Molte classi correlate differiscono fra loro solo per il
	      comportamento. Strategy fornisce un modo per configurare una classe
	      con un comportamento scelto fra tanti.

	\item Sono necessarie più varianti di un algoritmo. Lo Strategy pattern può
	      essere usato quando questi algoritmi sono implementati come classi
	      separate che possono essere selezionate in fase di esecuzione.

	\item Un algoritmo usa una struttura dati che non dovrebbe essere resa nota
	      ai client. Il pattern Strategy può essere usato per evitare di esporre
	      strutture dati complesse e specifiche dell'algoritmo.

	\item Una classe definisce molti comportamenti che compaiono
	      all'interno di scelte condizionali multiple. Al posto di molte scelte
	      condizionali, si suggerisce di spostare i blocchi di codice correlati
	      in una classe Strategy dedicata.
\end{enumerate}

\section{Template Method}

Applicabilità:
\begin{enumerate}
	\item Per implementare la parte invariante di un algoritmo e lasciare alle
	      sottoclassi la possibilità di implementare la parte variabile.

	\item Un comportamento comune fra sottoclassi deve essere portato a
	      fattore comune e localizzato in una classe comune per evitare codice
	      duplicato.

	\item Controllare le estensioni di sottoclassi. Permette di definire
	      metodi template che chiamano metodi hook in punti specifici, permettendo
	      quindi alle sottoclassi di estendere solo quei punti.
\end{enumerate}
\end{document}
