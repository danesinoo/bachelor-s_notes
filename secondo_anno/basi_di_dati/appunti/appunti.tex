\documentclass{article}

\usepackage{listings}
\usepackage{xcolor}
\lstset { %
    language=C++,
    backgroundcolor=\color{black!5}, % set backgroundcolor
    basicstyle=\footnotesize,% basic font setting
}

\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{caption}
\usepackage{fancyhdr}
\usepackage{geometry}
	\geometry{height=24 cm}
	\geometry{left=2.5 cm}
	\geometry{right=2.5 cm}
	\geometry{top=2 cm}
	\geometry{headheight=1 cm}

\setcounter{secnumdepth}{2}

\newtheorem{definition}{Def.}[section]

\def\ojoin{\setbox0=\hbox{$\bowtie$}%
  \rule[-.02ex]{.25em}{.4pt}\llap{\rule[\ht0]{.25em}{.4pt}}}

\title{\vspace{2cm}\textbf{Appunti di Basi di Dati}}
\author{\vspace{3mm}4 ottobre 2022}
\date{\vspace{3mm} \textbf{Rosso Carlo}}

\begin{document}

\begin{titlepage}
	\maketitle
	\thispagestyle{empty}
\end{titlepage}
\tableofcontents
\newpage

\section{introduzione}
\begin{definition}[base di dati]
	insieme organizzato, persistente e condiviso di dati utilizzati per lo
	svolgimento delle attività \textit{automatizzate} di un'organizzazione.
\end{definition}

\begin{definition}[dato]
	ciò che è immediatamente presente alla conoscenza, prima di ogni
	elaborazione.
\end{definition}

\begin{definition}[informazione]
	notizia, dato o elemento che consente di avere conoscenze più o meno esatte
	di fatti, situazioni, modi di essere.
\end{definition}

Elaborazione dei dati permette di estrarre delle informazioni dai dati.

\begin{definition}[DataBaes Management System (DBMS)]
	Le basi di dati sono gestite da un DBMS. Una base di dati è grande,
	persistenete e condivisa. 
	Ovvero, grandi: il limite deve essere solo quello fisico dei dispositivi;
	persistenti: indipendente dalle singole esecuzioni dei programmi; condivise:
	applicazioni e utenti diversi accedono ad una porzione (sovrapponibile)
	delle basi di dati).

	Un DBMS garantisce alla base di dati: privacy,
	affidabilità, efficienza, efficacia.
\end{definition}

La proprietà della condivisione che caratterizza i database ha alcuni problemi
che devono essere risolti:
\begin{itemize}
	\item ridondanza: dati duplicati;
	
	\item incoerenza: le versioni possono non coincidere;

	\item privacy: i fruitore delle basi di dati devono accedere ai dati per cui
		sono autorizzati.
\end{itemize}

Le soluzioni sono le seguenti:
\begin{itemize}

	\item indipendenza delle operazioni: sono permesse attività diverse
		solo su dati diversi; dunque, sono previsti meccanismi di
		autorizzazione, per garantire la sequenzialità delle operazioni;

	\item accessi di più utenti a dati condivisi: meccanismi di controllo della
		concorrenza e talvolta è impiegato l'uso di lock e semafori.
\end{itemize}

I DBMS garantiscono affidabilità sfruttando le transazioni.

\begin{definition}[transazioni]
	insieme di operazioni, da considerare indivisibile, corrette anche in 
	presenza di concorrenza e con effeti definitivi.
\end{definition}

\begin{definition}[schema]
	lo schema è quasi un'invariante nel tempo. Si tratta della descrizione delle
	tabelle contenute nel database.
\end{definition}

\begin{definition}[istanza]
	è la rappresentazione dei dati in un dato momento, nei modi indicati
	attraverso lo schema. L'istanza è soggetta a variazioni nel tempo.
\end{definition}

Un contributo all'efficacia dei DBMS è la disponibilità di vari linguaggi e
interfacce. Per esempio il linguaggio testuale interattivo SQL, che si impegna a
rappresentare l'algembra relazionale. In realtà i comandi SQL possono essere
immersi in un linguaggio ospite, come ad esempio C++. Oppure si può gestire un
DBMS attraverso un'interfaccia amichevole.

\textbf{SQL} svolge una doppia funzione: è un data manipulation language (DML),
per cui, permette di interrogare e di aggiornare istanze di basi di dati; è un
data definition language (DDL), per cui, permette di definire e modificare gli
schemi.

\begin{table}[h]
	\label{tab:pro_contro_DBMS}
	\center
	\begin{tabular}{l l}
		\textbf{Pro} & \textbf{Contro} \\
		\hline
		condividere i dati in un'organizzazione & ne vale la pena solo per
		grandi organizzazioni \\
		gestione centralizzata, easy to scale & non utilizzare senza tanti
		utenti \\
		servizi integrati & non utilizzare senza accessi concorrenti e stabili
		\\
		riduzione di ridondanze e inconsistenze & \\
		indipendenza dei dati per la manutenzione e lo sviluppo & \\
	\end{tabular}
	\caption{Pro e contro dei DBMS}
\end{table}

\section{Algebra relazionale}
\begin{definition}[relazione]
	una relazione è un insieme di tuple (attributi), ciascuna delle quali è un 
	insieme di valori, uno per ogni attributo. Gli attributi non hanno ordine, 
	gli elementi dell'insieme non hanno ordine. Per cui (in un database), 
	l'ordinamento tra le righe è irrilevante; l'ordinamento tra le colonne è 
	irrilevante; le righe sono diverse tra loro; le intestazioni delle colonne 
	sono diverse tra loro; i valori di ogni colonna sono definiti su domini 
	omogenei.
\end{definition}

Talvolta, l'attributo di un'istanza potrebbe non avere alcun valore. In questo
caso si ricorre all'utilizzo di valori speciali, che indicheranno l'assenza di
valore. Questo permette di imporre restrizioni sulla presenza di valori nulli.
Il valore nullo può avere tre origini, nasconde uno di tre significati: il
valore è sconosciuto; il valore non esiste; il valore non ha informazione
intrinseca.

\begin{definition}[sintatticamente corrette]
	tutte le tuple sono diverse tra loro.
\end{definition}

\begin{definition}[semanticamente corrette]
	tutte le tuple rispettano le restrizioni imposte. I valori assunti hanno
	senso per l'applicazione di interesse.
\end{definition}

\subsection{vincoli intrarelazione}
\begin{definition}[non nullo]
	Data $r$ di $R=A_1, \dots, A_n$, e $A_i \in R$, allora si dice che $A_i$ è
	non nullo in $r$ se e solo se per ogni $t \in r, t[A_i]$ è definita.
\end{definition}

\begin{definition}[unicità]
	Sia $\bar{R} = A_{i_1}, \dots, A_{i_k} \subset R$ un sottoinsieme non vuoto 
	($k \geq 1$). Allora si dice che $\bar{R}$ è unico in $r$ se e solo se per
	ogni $t_1, t_2 \in r, t_1[\bar{R}], t_2[\bar{R}]$ definiti abbiamo 
	$t_1[\bar{R}] = t_2[\bar{R}] \Rightarrow t_1 = t_2$.
\end{definition}

\begin{definition}[superchiave]
	$\bar{R}$ si un'instanza $r$ di $R$ è un sottoinsieme $\bar{R} \subset R$
	che soddisfa il vincolo di unicità su r.
\end{definition}

\begin{definition}[chiave]
	$\bar{R}$ di un'istanza di $R$ è una superchiave $\bar{R} \subset R$ per r
	tale che $\forall \tilde{R} \subset \bar{R}, \tilde{R}$ non è una
	superchiave per $R$ (minimalità).
\end{definition}

\begin{definition}[chive primaria (primary key, pk)]
	$\bar{R}$ di $r$ su $R$ è una chiave di $r$ per cui vale non nulla su ogni
	attributo di $\bar{R}$ in $r$.
\end{definition}

\begin{definition}[schema di relazione]
	Lo schema di una relazione $R$ è costituito da una relazione $R$ e un
	insieme di vincoli $V_i, \dots, V_c$ intrarelazionali su $R$.
\end{definition}

\begin{definition}[istanza (valida) di uno schema]
	$r$ di $R$ è un'istanza (valida) di $R$ se e solo se $r$ soddisfa $V_1,
	\dots, V_c$.
\end{definition}

\subsection{vincoli interrelazionali}
\begin{definition}[chiave esterna (foreign key)]
	Date 2 relazioni $R_s = A_1, \dots, A_{m_a}$, $R_t= B_1, \dots, B_{m_b}$,
	una chiave esterna da $R_s$ verso $R_t$ è un insieme finito di coppie $FK =
	\{(A_{i_1}, B_{j_1}), \dots, (A_{i_k}, B_{j_k})\}$, dove $B_{j_i}$, tale che
	$x \in [1, \dots, k]$, sono tutti distinti e $Dom(A_{i_x}) = Dom(B_{j_x})$
	per ogni $x \in [1, \dots, k]$.
\end{definition}

\begin{definition}[vincolo di chiave esterna]
	$R_s=A_1, \dots, A_{m_a}, R_t=B_1, \dots, B_{m_b}$, $FK = \{(A_{i_1},
	B_{j_1}), \dots, (A_{i_k}, B_{j_k})\}$, da $R_s$ verso $R_t$, $r$ di $R_s$,
	$\bar{r}$ di $R_t$, allora si dice che $r$ soddisfa il vincolo di chiave
	esterna $FK$ se e solo se:
	\begin{enumerate}
		\item $B_{j_1}, \dots, B_{j_k}$ è pk in $\bar{r}$;

		\item sia $\forall t \in r$, tale che $t[A_{i_1}], \dots, t[A_{i_k}]$
			definito, allora $\exists \bar{t} \in \bar{r}$ tale che $t[A_{i_1}]
			, \dots, t[A_{i_k}] = \bar{t}[B_{j_1}], \dots, \bar{t}[B_{j_k}]$.
	\end{enumerate}
\end{definition}

\subsection{operatori su relazioni}
L'insieme degli operatori su relazioni producono relazioni e possono essere
composti. Operatori insiemistici, le relazioni sono insiemi, il risultato sono
altre relazioni è possibile applicare unione, intersezione e differenza solo a
relazioni definite sugli stessi attributi.

\paragraph{ridenominazione [$\rho$]} modifica lo schema lasciamo inalterata 
l'istanza
dell'operando. La ridenominazione è un operatore unario.

\paragraph{selezione [$\sigma$]} il codominio è un sottoinsieme del dominio. 
La selezione è
un operatore unario. Sono tolte delle tuple.

\paragraph{proiezione [$\pi$]} il codominmio è un sottoinsieme del dominio. La
proiezione è un operatore unario. Sono tolti degli attributi.
Notiamo che se $X$ è una superchiave di $R$, allora $\pi_X(R)$ ha cardinalità
uguale a quella di $R$.

\paragraph{join [$\bowtie$]} operatore binario su due relazioni A e B. Il 
risultato è
l'unione degli attributi degli operandi; in particolare, il risultato sono le
tuple costruite com e$A \times B$ mantenendo quelle con valori uguali su
attributi uguali.

Date due relazioni $R_1(X_1), \ R_2(X_2), \ R_1 \bowtie R_2$ è una relazione su
$X_1X_2$, ovvero $X_1 \cup X_2$, del tipo 

\begin{equation}
	R_1 \bowtie R_2 = \{t \in X_1X_2 \ | \ t[X_1] \in R_1, \ t[X_2] \in R_2\}.
\end{equation}

\paragraph{$\Theta$-join} si tratta del prodotto cartesiano tra le relazioni
operando. Diventa utile se combinato alla selezione, infatti si impone una
condizione che deve essere rispettata. In effetti Il $\Theta$-join è un
join a cui è applicata la selezione:
\begin{equation}
	\sigma_{condizione}(R_1 \bowtie R_2) = R_1 \bowtie_{condizione} R_2.
\end{equation}

In algebra, due espressioni sono equivalenti se producono lo stesso risultato
qualunque sia l'istanza attuale delle relazioni della base di dati.

I DBMS usano regole di equivalenza per ottimizzare le interrogazioni.
L'obiettivo delle ottimizzazioni è quello di minimizzare il numero di tuple e di
attributi nelle relazioni intermedie.

In SQL esistono forme apposite per riferirsi ai valori nulli: \texttt{IS NULL}
e \texttt{IS NOT NULL}.

\subsection{viste}
Le viste sono rappresentazioni diverse per gli stessi dati; ovvero, sono
relazioni il cui contenuto è funzione del contenuto di altre relazioni.

Alle viste si contrappongono le relazioni di base, che hanno contenuto autonomo.

\paragraph{viste materializzate} si tratta di relazioni derivate (in quanto si
tratta di viste) memorizzate nella base di dati. Il pro delle viste
materializzate è che non c'è bisogno di ricalcolare la vista ogni volta che
viene richiesta. I contro sono che: le informazioni sono ridondanti; aggiornare
il database diventa un processo più lento; raramente sono supportate dai DBMS.

\paragraph{viste virtuali (o viste)} sono supportate da tutti i DBMS. Una
interrogazione su una vista viene eseguita "ricalcolando" la vista, a meno di
ottimizzazioni interne da parte del DBMS.\\

Le viste permettono di avere degli schemi esterni. Per cui, si mostra agli
utenti solo ciò che sono interessati a conoscere. Inoltre, semplifica la
scrittura di interrogazioni complesse. Diventa possibile riutilizzare programmi
già esistenti su schemi ristrutturati. L'utilizzo di viste non influisce
sull'efficienza delle interrogazioni, perché il DBMS ottimizza le
interrogazioni.

\section{Forme Normali}
\begin{definition}[forma normale]
	Una forma normale è una proprietà di una base di dati relazionale che ne
	garantische la "qualità", cioè l'assenza di determinati difetti.
\end{definition}

NB quando una relazione non è normalizzata, presenta ridondanze; oppure si presta
a comportamenti poco desiderabili durante gli aggiornamenti.

La normalizzazione è il processo che permette di trasformare uno schema non
normalizzato in uno schema che soddisfa una forma normale. La normalizzazione è
usata come tecnica di controllo dei risultati della progettazione di una base di
dati.

\begin{definition}[dipendenza funzionale]
	Condizioni:
	\begin{itemize}
		\item sia $R$ una relazione su $X$;

		\item dati due insiemi di attributi $A, B \subset X$;

		\item $\forall t_1, t_2 \in R$, se $\pi_A(t_1) = \pi_A(t_2)$, allora
			$\pi_B(t_1) = \pi_B(t_2)$.
	\end{itemize}

	Allora si dice che esiste in $R$ una dipendenza funzionale $A 
	\rightarrow B$.
\end{definition}

\begin{definition}[forma normale di Boyce-Codd (BCNF)]
	Condizioni:
	\begin{itemize}
		\item $R$ è una relazione su $X$;

		\item $K_1, \dots, K_n$ sono chiavi di $R$;

		\item $F$ è l'insieme delle dipendenze funzionali su $R$;

		\item $\forall f \in F$ tale che $f = X \rightarrow Y$, $X$ è 
			superchiave.
	\end{itemize}

	Allora si dice che $R$ è in forma normale di Boyce-Codd.
\end{definition}

\begin{definition}[decomposizione senza perdita]
	Condizioni:
	\begin{itemize}
		\item $R$ è una relazione su $X$;

		\item $R_1, \dots, R_n$ sono relazioni su $X$;

		\item $\cup_{R_i} = R$;

		\item $\pi_{R_1}(R) \bowtie \dots \bowtie \pi_{R_n}(R) = R$.
	\end{itemize}

	Allora si diche che la relazione $R$ si decompone senza perdita su $R_1,
	\dots, R_n$.
\end{definition}

NB una decomposizione senza perdita è garantita se gli attributi in $R_i \cap
R_j$, con $i \neq j$, sono una chiave per $R_i$ o (non esclusivo) $R_j$.\\
Una decomposizione dovrebbe sempre preservare le dipendenze funzionali, ovvero i
vincoli di integrità originari della relazione.

NB La forma normale di Boyce-Codd non è sempre raggiungibile, ecco perchè in
genere si usa la terza forma normale.

\begin{definition}[terza forma normale (3NF)]
	Una relazione $R$ è in terza forma normale se per ogni dipendenza funzionale 
	non banale $X \rightarrow Y$, almeno una delle seguenti condizioni è vera:
	\begin{itemize}
		\item $X$ è superchiave;

		\item ogni attributo in $Y$ è contenuto in una chiave di $R$.
	\end{itemize}
\end{definition}

La terza forma normale è una forma normale più debole della BCNF, ma ha il pro
di essere sempre raggiungibile. Una possibile strategia è quella di decomporre
in terza forma normale e poi si verifica se lo schema ottenuto è anche in BCNF.

\begin{definition}[seconda forma normale (2NF)]
	Una relazione è in seconda forma normale se la relazione non ha attributi 
	che dipendono funzionalmente da una parte della chiave.
\end{definition}

\begin{definition}[chiusura]
	Condizioni:
	\begin{itemize}
		\item sia $R$ una relazione su $X$;

		\item sia $F$ un insieme di dipendenze funzionali definite su $X$;

		\item sia $A$ un insieme di attributi di $X$.

		\item sia $A^+_F = \{B \in X | \exists f \in F $ tale che $ f =A 
			\rightarrow B\}$.
	\end{itemize}

	Allora si diche che $A^+_F$ è la chiusura di $A$ rispetto a $F$, ovvero è
	l'insieme di tutti gli attributi che dipendono funzionalmente da X.
\end{definition}

NB se $\{X_1, X_2 \} \rightarrow Y$ allora $\{X_1, X_2, \dots \} \rightarrow
Y$.\\

Sia $F$ un insieme di dipendenze funzionali su $R$. Ecco alcune proprietà
desiderabili:
\begin{itemize}
	\item $F$ sia \textbf{non ridondante}: non esiste dipendenza $f
		\in F$ tale che $F - \{f\} \Rightarrow f$;

	\item $F$ sia \textbf{ridotto}: non esiste un insieme $F'$ di dipendenze
		funzinali su $R$ equivalente a $F$, ottenuto eliminando attributi dai
		primi membri delle dipendenze funzionali di $F$;
\end{itemize}

\section{transazioni}
\begin{definition}[transazione]
	Una transazione è un'unità di elaborazione che gode delle proprietà ACID:
	atomicità, consistenza, isolamento e durabilità.
	Una transazione è una parte del programma caratterizzata da:
	\begin{enumerate}
		\item inizio di transazione (begin-transaction);

		\item corpo della transazione: una serie di insert, delete e update in 
			SQL;

		\item fine transazione (end-transaction): una transazione si può 
			concludere:
			\begin{itemize}
				\item commit: terminazione corretta, i cambiamenti sono 
					definitivi;

				\item rollback: la transazione è abortita, si torna allo stato
					antecedente l'inizio della transazione.
			\end{itemize}
	\end{enumerate}
\end{definition}

\begin{definition}[proprietà ACID]

	\item \textbf{Atomicità}: una transazione deve essere eseguita completamente
		o non deve essere eseguita affatto;

	\item \textbf{Consistenza}: una transazione deve portare il database da uno 
		stato consistente ad un altro stato consistente;

	\item \textbf{Isolamento}: una transazione non espone i suoi stati 
		intermedi;

	\item \textbf{Durabilità}: una transazione che ha fatto commit non può 
		essere persa.
\end{definition}

Una sistema transazione (OLTP) è in grado di definire ed eseguire transazioni
per un certo numero di applicazioni concorrenti. C'è un log che permette di
effettuare \textit{undo/redo}. Si tratta di un archivio permanente delle
operazioni svolte sul database. Le regole fondamentali del log sono:
\begin{itemize}
	\item write-ahead-log: si scrive il log prima del database;

	\item commit-precedence: il log di un commit precede il commit stesso;
\end{itemize}

\subsection{livello di isolamento}
Il livello di isolamento può essere scelto per ogni transazione:
\begin{itemize}
	\item read uncommitted;

	\item read committed;

	\item repeatable read;

	\item serializable;
\end{itemize}

Per capire la differenza tra i livelli di isolamento spieghiamo gli errori che
si possono verificare:
\begin{itemize}
	\item perdita di aggiornamento (loss update(?)): due transazioni scrivono lo
		stesso dato, ma solo l'ultimo viene mantenuto;

	\item lettura sporca (dirty write): una transazione legge un dato che è
		stato scritto da un'altra transazione che poi abortisce;

	\item letture inconsistenti (non-repeatable read): una transazione legge
		lo stesso dato due volte, ma il valore è cambiato;

	\item aggiornamento fantasma: un dato appare "improvvisamente" aggiornato.

	\item inserimento fantasma (phantom): una transazione legge un insieme di 
		dati, poi una seconda transazione inserisce un nuovo dato che soddisfa 
		la condizione della prima transazione, che però non lo vede.
\end{itemize}

Di seguito la tabella che riassume i livelli di isolamento:
\begin{center}
	\begin{tabular}{|c|c|c|c|c|}
		\hline
		& & & & \\
		Anomalie & read uncommitted & read committed & repeatable read & 
		serializable \\
		\hline
		perdita di aggiornamento & \checkmark & \checkmark & \checkmark & 
		\checkmark \\
		\hline
		lettura sporca & - & \checkmark & \checkmark & \checkmark \\
		\hline
		letture inconsistenti & - & - & \checkmark & \checkmark \\
		\hline
		aggiornamento fantasma & - & - & \checkmark  & \checkmark \\
		\hline
		inserimento fantasma & - & - & - & \checkmark \\
		\hline
	\end{tabular}
\end{center}

\section{schedule}

\begin{definition}[schedule]
	Uno schedule è un'insieme di operazioni di input e output di transazioni
	concorrenti.
\end{definition}

\begin{definition}[scheduler]
	un sistema che accetta o rifiuta o riordina le operazioni richieste dalle
	transazioni.
\end{definition}

\begin{definition}[serial schedule]
	Uno schedule è seriale se le operazioni di ogni transazione sono eseguite
	in modo consecutivo, una per volta.
\end{definition}

\begin{definition}[legge-da]
	$r_i(x)$ legge da $w_j(x)$ in uno schedule S, se $w_j(x)$ precede $r_i(x)$
	e non esiste $w_k(x)$ tale che $w_j(x)$ si trova tra $w_j(x)$ e $r_i(x)$ in
	S.
\end{definition}

\begin{definition}[scrittura-finale]
	$w_j(x)$ è una scrittura finale di $x$ in uno schedule S se non esiste
	$w_k(x)$ tale che $w_j(x)$ precede $w_k(x)$ in S.
\end{definition}

\begin{definition}[view-equivalente]
	Se due schedule $S_1, S_2$ hanno la stessa relazione legge-da e le stesse 
	scritture finali, allora si dice che sono
	view-equivalenti ($S_1 \equiv S_2$).
\end{definition}

\begin{definition}[view-serializzabile (VSR)]
	Uno schedule è serializzabile se è view-equivalente ad un qualche schedule 
	seriale.
\end{definition}

NB la verifica della view-equivalenza di due dati schedule è lineare sulla
lunghezza dello schedule. Decidere sulla view'serializzabilità di uno schedule
$S$ è un problema in NP, perché occorre provare tutti i possibili schedule
seriali, ottenuti per permutazioni dell'ordine delle transazioni. Vuol dire che
nella pratica non è utilizzabile.

\begin{definition}[conflitto]
	Siano $a_i, a_j$ tali che $i \neq j$ due opearzioni che opearano sullo
	stesso oggetto. Se almeno una delle due è una scrittura, allora si dice che
	sono in conflitto.
\end{definition}

\begin{definition}[schedule conflict-equivalenti]
	Siano $S_i, S_j$ due schedule, tali che includono le stesse operazioni e 
	ogni coppia di opearzioni in conflitto compare nello stesso ordine in 
	entrambi, allora si dice che sono schedule conflict-equivalenti.
\end{definition}

\begin{definition}[schedule conflict-serializzabili (CSR)]
	Uno schedule è conflict-serializzabile se è conflict-equivalente ad un 
	schedule seriale.
\end{definition}

NB $CSR \subset VSR$.

\begin{definition}[two phase locking (2PL)]
	Tutte le letture per una risorsa $x$ sono precedute da $r_{lock}(x)$ e sono
	seguite da $unlock(x)$. Tutte le scritture per una risorsa $x$ sono 
	precedute da $w_{lock}(x)$ e sono seguite da $unlock(x)$.

	Inoltre, una transazione dopo aver rilasciato un lock, non può acquisirne
	altri.
\end{definition}

NB $2PL \subset CSR$.

Riassumento da capo abbiamo che: $schedule\_seriale \subset 2PL \subset CSR
\subset VSR \subset schedule$.
\end{document}
