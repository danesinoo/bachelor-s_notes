\documentclass[11pt]{article}
 \renewcommand{\familydefault}{\sfdefault}

\usepackage{listings}
\usepackage{xcolor}
\lstset { %
    language=C++,
    backgroundcolor=\color{black!5}, % set backgroundcolor
    basicstyle=\footnotesize,% basic font setting
}

\title{\vspace{2cm}\textbf{Appunti di Automi e Linguaggi Formali}}
\author{\vspace{3mm}17 Agosto 2023}
\date{\vspace{3mm} \textbf{Rosso Carlo}}

\usepackage{comment}
\usepackage{tabularx}
\usepackage{changepage}
\usepackage{amsfonts}
\usepackage{float}
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{caption}
\usepackage{fancyhdr}
\usepackage{geometry}
	\geometry{height=24 cm}
	\geometry{left=2.5 cm}
	\geometry{right=2.5 cm}
	\geometry{top=2 cm}
	\geometry{headheight=1 cm}

\setcounter{secnumdepth}{2}
\linespread{1}
\renewcommand{\labelitemi}{-}
\newtheorem{definition}{Def.}[section]
\newtheorem{theorem}{Teorema}[section]
\newtheorem{proof}{Dimostrazione}[section]


\begin{document}

\begin{titlepage}
	\maketitle
	\thispagestyle{empty}
\end{titlepage}
\tableofcontents
\newpage

\section{Introduzione}
La teoria della computazione si pone una domanda: che cos'è un computer?
Idealiziamo un computer come un modello computazionale. Un modello
computazionale può essere preciso in qualche aspetto, ma non in altri. Per
questo motivo studiamo diversi modelli computazionali, in base alle
caratteristiche che ci interessano. Cominciamo con il modello computazionale più
semplice: l'automa a stati finiti (DFA, Deterministic Finite Automaton).

\section{Automi a stati finiti}

\subsection{Definizione}

\begin{definition}[Automa a stati finiti]
	Un automa finito è una quintupla $(Q, \Sigma, \delta, q_0, F)$ 
	dove:
	\begin{enumerate}
		\item $Q$ è un insieme finito chiamato insieme degli stati;
		\item $\Sigma$ è un insieme finito chiamato alfabeto;
		\item $\delta: Q \times \Sigma \rightarrow Q$ è la funzione di 
			transizione;
		\item $q_0 \in Q$ è lo stato iniziale;
		\item $F \subseteq Q$ è l'insieme degli stati finali.
	\end{enumerate}
\end{definition}

Se $A$ è l'insieme delle stringhe accetate da un DFA $M$, allora $A$ è il
linguaggio di $M$, e lo indichiamo con $L(M)$. E diciamo che $M$ accetta $A$.

\begin{definition}[Computazione]
	Sia $M = (Q, \Sigma, \delta, q_0, F)$ un DFA e $w = w_1w_2 \dots w_n$ una
	stringa su $\Sigma$. Diciamo che $M$ accetta $w$ se esiste una sequenza di
	stati (computazione) $r_0, r_1, \dots, r_n$ in $Q$ tale che:
	\begin{enumerate}
		\item $r_0 = q_0$;
		\item $r_{i+1} = \delta(r_i, w_{i+1})$ per $i = 0, 1, \dots, n-1$;
		\item $r_n \in F$.
	\end{enumerate}
\end{definition}

\begin{definition}[Linguaggio regolare]
	Un linguaggio si dice regolare se qualche DFA lo accetta.
\end{definition}

\subsection{Operazioni sui linguaggi regolari}

\begin{definition}[Unione]
	Siano $A$ e $B$ due linguaggi.
	\begin{itemize}
		\item[] $A \cup B = \{x \mid x \in A \text{ oppure } x \in B\}$.
	\end{itemize}
\end{definition}

\begin{definition}[Concatenazione]
	Siano $A$ e $B$ due linguaggi.
	\begin{itemize}
		\item[] $A \circ B = \{xy \mid x \in A \text{ e } y \in B\}$.
	\end{itemize}
\end{definition}

\begin{definition}[Star]
	Sia $A$ un linguaggio.
	\begin{itemize}
		\item[] $A^* = \{x_1x_2 \dots x_k \mid k \geq 0 \text{ e } x_i \in A
			\text{ per } i = 1, 2, \dots, k\}$.
	\end{itemize}
\end{definition}

\subsection{Automa a stati finiti non deterministico}

Definiamo $\epsilon$ come la stringa vuota e $\mathcal{P}(A)$ come l'insieme delle parti
di $A$.

\begin{definition}[Automa a stati finiti non deterministico]
	Un automa a stati finiti non deterministico (NFA, Nondeterministic Finite
	Automaton) è una quintupla $(Q, \Sigma, \delta, q_0, F)$ dove:
	\begin{enumerate}
			\item $Q$ è un insieme finito chiamato insieme degli stati;
			\item $\Sigma$ è un insieme finito chiamato alfabeto;
			\item $\delta: Q \times (\Sigma \cup \{\epsilon\}) \rightarrow
				\mathcal{P}(Q)$ è la funzione di transizione;
			\item $q_0 \in Q$ è lo stato iniziale;
			\item $F \subseteq Q$ è l'insieme degli stati finali.
	\end{enumerate}
	\textbf{NB}: $\delta$ è una funzione che mappa un elemento di $Q$ e un
	elemento di $\Sigma \cup \{\epsilon\}$ in un sottoinsieme di $Q$, quindi
	anche $\emptyset$.
\end{definition}

\begin{definition}[Computazione]
	Sia $M = (Q, \Sigma, \delta, q_0, F)$ un DFA e $w = w_1w_2 \dots w_n$ una
	stringa su $\Sigma$. Diciamo che $M$ accetta $w$ se esiste una sequenza di
	stati (computazione) $r_0, r_1, \dots, r_n$ in $Q$ tale che:
	\begin{enumerate}
		\item $r_0 = q_0$;
		\item $r_{i+1} \in \delta(r_i, w_{i+1})$ per $i = 0, 1, \dots, n-1$;
		\item $r_n \in F$.
	\end{enumerate}
\end{definition}

\begin{definition}[Equivalenza tra automi]
	Diciamo che due automi $M_1$ e $M_2$ sono equivalenti se $L(M_1) = L(M_2)$.
\end{definition}

\begin{theorem}[Equivalenza tra DFA e NFA]
	Ogni automa a stati finiti non deterministico ha un equivalente
	deterministico.
\end{theorem}

\subsection{Espressioni regolari}

\begin{definition}[Espressione regolare]
	R è un espressione regolare se vale una delle seguenti:
	\begin{itemize}
		\item $a$ per qualche $a \in \Sigma$;
		\item $\epsilon$;
		\item $\emptyset$;
		\item $(R_1 \cup R_2)$ dove $R_1$ e $R_2$ sono espressioni regolari;
		\item $(R_1 \circ R_2)$ dove $R_1$ e $R_2$ sono espressioni regolari;
		\item $(R_1^*)$ dove $R_1$ è un'espressione regolare.
	\end{itemize}
\end{definition}

\begin{theorem}
	Un linguaggio è regolare se e solo se qualche espressione regolare lo
	genera.
\end{theorem}

\subsection{Pumping Lemma}

\begin{theorem}[Pumping Lemma]
	Sia $A$ un linguaggio regolare. Allora esiste un numero $p$ (detto pumping
	length) tale che per ogni stringa $s \in A$ con $|s| \geq p$ esiste una
	suddivisione $s = xyz$ tale che:
	\begin{enumerate}
		\item $|y| > 0$;
		\item $|xy| \leq p$;
		\item per ogni $i \geq 0$, $xy^iz \in A$.
	\end{enumerate}
\end{theorem}


\section{Grammatica context-free}

\begin{definition}[Grammatica context-free]
	Una grammatica context-free (CFG, Context-Free Grammar) è una quadrupla
	$(V, \Sigma, R, S)$ dove:
	\begin{enumerate}
		\item $V$ è un insieme finito chiamato insieme delle variabili;
		\item $\Sigma$ è un insieme finito, disgiunto da V, chiamato insieme dei
			terminali;
		\item $R$ è un insieme finito di regole, ciascuna delle quali è una
			coppia $(v, w)$ dove $v \in V$ e $w \in (V \cup \Sigma)^*$;
		\item $S \in V$ è la variabile iniziale.
	\end{enumerate}
\end{definition}

È intuitivo, ma vediamo come costruire una grammatica CF a partire da un DFA:
\begin{enumerate}
	\item $\forall q_i \in Q \, \ \exists r_i \in R$;
	\item $\Sigma_{CFG} = \Sigma_{DFA}$;
	\item $r_i \rightarrow ar_j \in R$ per ogni $q_j = \delta(q_i, a)$, tale che
		$a \in \Sigma_{DFA}$;
	\item $r_i \rightarrow \epsilon \in R$ per ogni $q_i \in F$;
	\item $S = q_0$.
\end{enumerate}

\begin{definition}[Ambiguità]
	Una grammatica è ambigua se esiste una stringa $w$ tale che $w$ ha due
	alberi di derivazione distinti. In questo caso si dice che $w$ si deriva in
	modo ambiguo.
\end{definition}

\subsection{Forma normale}

\begin{definition}[Forma normale di Chomsky]
	Una grammatica è in forma normale di Chomsky se tutte le sue regole sono
	della forma:
	\begin{itemize}
		\item $A \rightarrow BC$;
		\item $A \rightarrow a$.
	\end{itemize}
	dove $A, B, C \in V$ e $a \in \Sigma$ e $B, C \neq S$.
\end{definition}

\begin{theorem}[Forma normale di Chomsky]
	Ogni linguaggio context-free è generato da una grammatica context-free in 
	forma normale di Chomsky.
\end{theorem}

\subsection{Automa a pila} 

\begin{definition}[Automa a pila]
	Un automa a pila (PDA, pushdown automaton) è una 6-upla $(Q, \Sigma, \Gamma,
	\delta, q_0, F)$, dove $Q, \Sigma, \Gamma e F$ sono insiemi finiti e:
	\begin{itemize}
		\item $Q$ è l'insieme degli stati;
		\item $\Sigma$ è l'alfabeto di input;
		\item $\Gamma$ è l'alfabeto dello stack;
		\item $\delta : Q \times (\Sigma \cup \{\epsilon\}) \times (\Gamma \cup
			\epsilon) \rightarrow \mathcal{P}(Q \times (\Gamma \cup \{\epsilon\}))$ 
			è la funzione di transizione;
		\item $q_0 \in Q$ è lo stato iniziale;
		\item $F \subseteq Q$ è l'insieme degli stati finali.
	\end{itemize}
\end{definition}

\begin{definition}[Computazione]
	Un PDA $M = (Q, \Sigma, \Gamma, \delta, q_0, F)$ accetta l'input $w$ se
	$w$ può essere scritta come $w = w_1w_2\dots w_n$ dove $w_i \in \Sigma$, 
	la sequenza di stati $r_0, r_1, \dots, r_n \in Q$ e le stringhe $s_0, s_1,
	\dots, s_n \in \Gamma^*$ esistono tali che valgono le seguenti condizioni:
	\begin{enumerate}
		\item $r_0 = q_0$ e $s_0 = \epsilon$;
		\item $(r_{i+1}, b) \in \delta(r_i, w_{i+1}, a)$ e $s_{i+1} = bt$ e $s_i
			= at$ per qualche $t \in \Gamma^*$ e $a, b \in \Gamma \cup 
			\{\epsilon\}$;
		\item $r_n \in F$.
	\end{enumerate}
\end{definition}

\begin{theorem}[Equivalenza tra PDA e CFG]
	Un linguaggio è context-free se e solo se è accettato da un PDA.
\end{theorem}

Dal precedente teorema otteniamo il corollario: ogni linguaggio regolare è
context-free.

\subsection{Pumping Lemma}

\begin{theorem}[Pumping Lemma]
	Sia $A$ un linguaggio context-free. Allora esiste un numero $p$ (detto
	pumping length) tale che per ogni stringa $s \in A$ con $|s| \geq p$ esiste
	una suddivisione $s = uvxyz$ tale che:
	\begin{enumerate}
		\item $|vy| > 0$;
		\item $|vxy| \leq p$;
		\item per ogni $i \geq 0$, $uv^ixy^iz \in A$.
	\end{enumerate}
\end{theorem}

\section{Macchina di Turing}

\begin{definition}[Macchina di Turing]
	Una macchina di Turin (TM, Turing Machine) è una 7-upla $(Q, \Sigma, \Gamma,
	\delta, q_0, q_{acc}, q_{rej})$, dove $Q, \Sigma, \Gamma$ sono insiemi 
	finiti e valgono le seguenti condizioni:
	\begin{enumerate}
		\item $Q$ è l'insieme degli stati;
		\item $\Sigma$ è l'alfabeto di input, non contiene il carattere
			speciale $\sqcup$;
		\item $\Gamma$ è l'alfabeto del nastro, tale che $\Sigma \subseteq
			\Gamma$ e $\sqcup \in \Gamma$;
		\item $\delta : Q \times \Gamma \rightarrow Q \times \Gamma \times
			\{L, R\}$ è la funzione di transizione;
		\item $q_0 \in Q$ è lo stato iniziale;
		\item $q_{acc} \in Q$ è lo stato di accettazione;
		\item $q_{rej} \in Q$ è lo stato di rifiuto, dove $q_{rej} \neq
			q_{acc}$.
	\end{enumerate}
\end{definition}

\begin{definition}[Configurazione]
	Una configurazione di una TM è una tripla $(q, x, y)$ dove $q \in Q$ è lo
	stato corrente, $x \in \Gamma^*$ è la stringa sul nastro che precede la
	posizione della testina e $y \in \Gamma^*$ è la stringa non vuota che segue 
	$x$, la testina si trova nel primo carattere di y. Un altro modo per
	rappresentare una configurazione è $xqy$.
\end{definition}

\textbf{NB}: la configurazione iniziale è $q_0w$ dove $w$ è la stringa di input.
In ogni configurazione di accetazione, lo stato corrente è $q_{acc}$. In ogni
configurazione di rifiuto, lo stato corrente è $q_{rej}$. Le configurazioni
di accettazione e di rifiuto sono dette configurazioni finali e bloccano la
TM.

\begin{definition}[Computazione]
	Si diche che una TM $M$ accetta l'input $w$ se esiste una sequenza di
	configurazioni $C_1, C_2, \dots, C_k$ tale che:
	\begin{enumerate}
		\item $C_1 = q_0w$;
		\item $C_i \text{ genera } C_{i+1} \text{ per } i = 1, \dots, k-1$;
		\item $C_k = q_{acc}$;
	\end{enumerate}
\end{definition}

L'insieme di strighe che $M$ accetta è detto linguaggio di $M$ e si indica con
$L(M)$.

\begin{definition}[Turing riconoscibile]
	Un linguaggio è Turing riconoscibile se è accettato da una TM.
\end{definition}

Quando facciamo partire una TM su un input, ci sono tre possibili risultati:
\begin{enumerate}
	\item la TM si blocca in uno stato di accettazione;
	\item la TM si blocca in uno stato di rifiuto;
	\item la TM entra in un loop infinito.
\end{enumerate}

\begin{definition}[Decisore]
	Una TM è un decisore se si blocca in uno stato di accettazione o di rifiuto
	per ogni input.
\end{definition}

\begin{definition}[Turing decidibile]
	Un linguaggio è Turing decidibile se è accettato da un decisore.
\end{definition}

\section{Decidibilità}

\begin{theorem}[$A_{DFA}$]
	Sia $A_{DFA} = \{\langle B, w \rangle \mid B \text{ è un DFA che accetta } 
	w\}$. Allora $A_{DFA}$ è decidibile.
\end{theorem}

\textbf{NB}: Si simula la computazione del DFA su $w$ e si controlla se si
controlla in quale stato si arriva alla fine della computazione.

\begin{theorem}[$A_{NFA}$]
	Sia $A_{NFA} = \{\langle B, w \rangle \mid B \text{ è un NFA che accetta } 
	w\}$. Allora $A_{NFA}$ è decidibile.
\end{theorem}

\textbf{NB}: Si converte un NFA in DFA e si applica il teorema precedente.

\begin{theorem}[$A_{REX}$]
	Sia $A_{REX} = \{\langle R, w \rangle \mid R \text{ è una regex che genera } 
	w\}$. Allora $A_{REX}$ è decidibile.
\end{theorem}

\textbf{NB}: Si converte la regex in un DFA e si applica il teorema precedente.

\begin{theorem}[$E_{DFA}$]
	Sia $E_{DFA} = \{\langle A \rangle \mid A \text{ è un DFA tale che } L(A) = 
	\emptyset\}$. Allora $E_{DFA}$ è decidibile.
\end{theorem}

\begin{proof}
Costruiamo la TM T che decide $E_{DFA}$:\\

$T = $ ``Sulla stringa di input $\langle A \rangle$, dove $A$ è un DFA:
\begin{enumerate}
	\item Segna lo stato iniziale di A;
	\item Ripeti finché nessuno stato nuovo viene segnato:
	\begin{enumerate}
		\item Segna ogni stato raggiungibile da uno stato segnato;
	\end{enumerate}
	\item Se uno stato finale non è segnato, allora accetta, altrimenti
		rifiuta.''
\end{enumerate}
\end{proof}

\begin{theorem}[$EQ_{DFA}$]
	Sia $EQ_{DFA} = \{\langle A, B \rangle \mid A \text{ e } B \text{ sono DFA e }
	L(A) = L(B)\}$. Allora $EQ_{DFA}$ è decidibile.
\end{theorem}

\textbf{NB}: Se $L(C) = (L(A) \cap \overline{L(B)}) \cup (\overline{L(A)} \cap
L(B)) = \emptyset$ allora $L(A) = L(B)$.

\begin{theorem}[$A_{CFG}$]
	Sia $A_{CFG} = \{\langle G, w \rangle \mid G \text{ è una CFG che genera } 
	w\}$. Allora $A_{CFG}$ è decidibile.
\end{theorem}

\begin{theorem}[$E_{CFG}$]
	Sia $E_{CFG} = \{\langle G \rangle \mid G \text{ è una CFG tale che } L(G) = 
	\emptyset\}$. Allora $E_{CFG}$ è decidibile.
\end{theorem}

\begin{proof}
Costruiamo la TM T che decide $E_{CFG}$:\\

$T = $ ``Sulla stringa di input $\langle G \rangle$, dove $G$ è una CFG:
\begin{enumerate}
	\item Segna tytti i simboli terminali di G;
	\item Ripeti finché nessuna nuova variabile viene segnata:
	\begin{enumerate}
		\item Segna ogni variabile V tale che G abbia una regola del tipo $V 
			\rightarrow U_1 U_2 \dots U_k$ tali che ogni $U_i$ è già stato
			seganto;
	\end{enumerate}
	\item Se la variabile di partenza di G non è segnata, allora accetta, 
		altrimenti rifiuta.''
\end{enumerate}
\end{proof}

\subsection{Problemi indecidibili}

\begin{theorem}[Halting problem]
	Sia $A_{TM} = \{\langle M, w \rangle \mid M \text{ è una TM che accetta } 
	w\}$. Allora $A_{TM}$ è indecidibile.
\end{theorem}

\begin{theorem}
	Un liguaggio è decidibile se e solo se è Turing riconoscibile e co-Turing
	riconoscibile.
\end{theorem}

\section{Riducibilità}

\begin{theorem}[$HALT_{TM}$]
	Sia $HALT_{TM} = \{\langle M, w \rangle \mid M \text{ è una TM che si ferma
	su } w\}$. Allora $HALT_{TM}$ è indecidibile.
\end{theorem}

\begin{proof}
Si suppone che $HALT_{TM}$ sia decidibile e si costruisce una TM
$T$ che decide $A_{TM}$, tale che $R$ è un desisore di $HALT_TM$:\\
$T = $ ``Sulla stringa di input $\langle M, w \rangle$, dove $M$ è una TM e
$w$ è una stringa:
\begin{enumerate}
	\item simula $R$ sull'input $\langle M, w \rangle$;
	\item se $R$ rifiuta, rifiuta;
	\item simula $M$ sull'input $w$ fino a che non si blocca;
	\item se M accetta, accetta, altrimenti rifiuta;''
\end{enumerate}

Dato che $R$ è un decisore di $HALT_{TM}$, se $R$ rifiuta, allora $M$ non si
blocca su $w$, quindi $M$ non accetta $w$. Se $R$ accetta, allora $M$ si blocca
su $w$, quindi la simulazione di $M$ su $w$ termina, rendendo $A_{TM}$ un
decisore. Questo è un assurdo, quindi $R$ non può esistere.
\end{proof}

\begin{theorem}[$E_{TM}$]
	Sia $E_{TM} = \{\langle M \rangle \mid M \text{ è una TM tale che } L(M) = 
	\emptyset\}$. Allora $E_{TM}$ è indecidibile.
\end{theorem}

\begin{proof}
Si suppone che $E_{TM}$ sia decidibile e si costruisce una TM
$T$ che decide $A_{TM}$. Sia $R$ è un desisore di $E_TM$:\\
$T = $ ``Sulla stringa di input $\langle M, w \rangle$, dove $M$ è una TM e
$w$ è una stringa:
\begin{enumerate}
	\item usa la descrizione di $M$ e $w$ per costuire $M_2$ tale che:\\
		$M_2 = $ ``Sulla stringa di input $x$:
		\begin{enumerate}
			\item se $x \neq w$ rifiuta;
			\item altrimenti simula $M$ su $w$, se $M$ accetta, accetta, se $M$
				rifiuta, rifiuta;''
		\end{enumerate}

	\item simula $R$ sull'input $M_2$;
	\item se $R$ rifiuta, accetta, se R accetta, rifiuta; ''
\end{enumerate}

Dato che $M_2$ arriva in uno stato di accettazione solo se $M$ accetta $w$.
Questo vuole dire che $L(M_2) = \emptyset$ se $M$ non accetta $w$ ed $L(M_2) =
\{ w \}$ se $M$ accetta $w$. Dunque se $R$, il decisore di $E_TM$, accetta, vuol
dire che $M$ non accetta $w$. Ma allora $T$ è un decisore di $A_TM$, questo è
assurdo, quindi $R$ non può essere un decisore di $E_TM$, allora $E_TM$ è
indecidibile.
\end{proof}

\begin{theorem}[$REGULAR_{TM}$]
	Sia $REGULAR_{TM} = \{\langle M \rangle \mid M$ è una TM tale che 
	$L(M)$ è un linguaggio regolare$\}$. Allora $REGULAR_{TM}$ è
	indecidibile.
\end{theorem}

\begin{proof}
	Si supponge che $REGULAR_{TM}$ sia decidibile e si costruisce una TM $T$
	tale che decide $A_{TM}$. Sia $R$ un decisore di $REGULAR_{TM}$:\\

	$T = $ ``Sulla stringa di input $\langle M, w \rangle$, dove $M$ è una TM e
	$w$ è una stringa:
	\begin{enumerate}
		\item usa $M$ e $w$ per costruire la TM $M_2$:\\

			$M_2 = $ ``Sulla stringa di input $x$:
			\begin{enumerate}
				\item se $x \in 0^n1^n$ accetta;
				\item altrimenti simula $M$ su $w$, se $M$ accetta, accetta,
					altrimenti rifiuta;''
			\end{enumerate}

		\item simula $R$ sull'input $\langle M \rangle$;

		\item se $R$ accetta, accetta; se $R$ rifiuta, rifiuta;''
	\end{enumerate}

	Se $M$ accetta $w$ allora $L(M_2) = \Sigma^*$ ed è un liguaggio regolare. Se
	$M$ rifiuta $w$ allora $L(M_2)$ non è regolare, quindi $R$ rifiuta. $T$ è un 
	decisore di $A_TM$, questo è assurdo, ma allora $R$ non può essere un
	decisore di $REGULAR_{TM}$. Dunque $REGULAR_{TM}$ è indecidibile.
\end{proof}

\begin{theorem}[$EQ_TM$]
	Sia $EQ_{TM} = \{\langle M_1, M_2 \rangle \mid M_1 \text{ e } M_2 \text{ sono
	TM tali che } L(M_1) = L(M_2)\}$. Allora $EQ_{TM}$ è indecidibile.
\end{theorem}

\begin{proof}
	Si supponga che $EQ_{TM}$ sia decidibile e si costruisce una TM $T$ che
	decide $E_{TM}$. Sia $R$ un decisore di $EQ_{TM}$:\\

	$T = $ ``Sulla stringa di input $\langle M \rangle$, dove $M$ è una TM:
	\begin{enumerate}
		\item Simula $R$ sull'input $\langle M, M_0 \rangle$, dove $M_0$ è una
			TM che rifiuta ogni stringa;
		\item se $R$ accetta, accetta; se $R$ rifiuta, rifiuta;''
	\end{enumerate}

	Se $L(M) = \emptyset$, allora $R$ accetta, perché $L(M) = L(M_0)$.
	Altrimenti $L(M) \neq L(M_0) = \emptyset$, quindi $R$ rifiuta. $T$ è un 
	decisore di $E_{TM}$, questo è assurdo, ma allora $R$ non può essere un
	decisore di $EQ_{TM}$. Dunque $EQ_{TM}$ è indecidibile.
\end{proof}

\begin{comment}
\begin{proof}
	Si supponge che $EQ_{TM}$ sia decidibile e si costruisce una TM $T$ che
	decide $A_{TM}$. Sia $R$ un decisore di $EQ_{TM}$:\\

	$T = $ ``Sulla stringa di input $\langle M, w \rangle$, dove $M$ è una TM e
	$w$ è una stringa:
	\begin{enumerate}
		\item usa $M$ e $w$ per costruire la TM $M_2$:\\

			$M_2 = $ ``Sulla stringa di input $x$:
			\begin{enumerate}
				\item se $x \neq w$ rifiuta;
				\item se $x = w$ simula $M$ sull'input $w$;
				\item se $M$ accetta, accetta, se $M$ rifiuta, rifiuta;''
			\end{enumerate}

		\item costruisce la TM $M_3$:\\

			$M_3 = $ ``Sulla stringa di input $x$:
			\begin{enumerate}
				\item se $x = w$ accetta, altrimenti rifiuta;''
			\end{enumerate}

		\item simula $R$ sull'input $\langle M_2, M_3 \rangle$;

		\item se $R$ accetta, accetta; se $R$ rifiuta, rifiuta;''
	\end{enumerate}

	Se $M$ accetta $w$ allora $L(M_2) = \{ w \} = L(M_3)$, quindi $R$ accetta.
	Se $M$ rifiuta $w$ allora $L(M_2) = \emptyset \neq L(M_3)$, quindi $R$
	rifiuta. $T$ è un decisore di $A_{TM}$, questo è assurdo, ma allora $R$ non
	può essere un decisore di $EQ_{TM}$. Dunque $EQ_{TM}$ è indecidibile.
\end{proof}
\end{comment}

\section{Complessità temporale}

\begin{definition}[Time]
	Sia $t: \mathbb{N} \rightarrow \mathbb{N}$ una funzione. Defniniamo la
	classe di complessità temporale $TIME(t(n))$
	\begin{equation}
		TIME(t(n)) = \{L \mid \text{ esiste una TM $M$ che decide $L$ in tempo
		$O(t(n))$}\}
	\end{equation}
\end{definition}

\begin{theorem}[Multitape TM]
	Una multitape TM che lavora in tempo $t(n)$ può essere simulata da una
	singletape TM che lavora in tempo $O(t^2(n))$.
\end{theorem}

\begin{theorem}[TM non deterministica]
	Una TM non deterministica che lavora in tempo $t(n)$ può essere simulata da
	una TM deterministica che lavora in tempo $2^{O(t(n))}$.
\end{theorem}

\begin{definition}[P (Polynomial time)]
	P è la classe dei linguaggi che sono decidibili in tempo polinomiale da una
	TM deterministica. Ovvero:
	\begin{equation}
		P = \bigcup_k TIME(n^k)
	\end{equation}
\end{definition}

\subsection{NP}

\begin{definition}[Verificatore]
	Un verificatore per un linguaggio $L$ è una TM $V$ tale che:
	\begin{equation}
		L = \{w \mid \text{ esiste una stringa } c \text{ tale che } V
			\text{ accetta } \langle w, c \rangle\};
	\end{equation}
	$c$ è chiamata certificato.
\end{definition}

In sostanza un verificatore è una TM che che verifica che una stringa $w$ sia
nel linguaggio $L$, avendo a disposizione informazioni aggiuntive per effettuare
la verifica più velocemente.

\begin{definition}[NP (Nondeterministic Polynomial time)]
	NP è la classe dei linguaggi che hanno un verificatore che lavora in tempo
	polinomiale. Ovvero:
\end{definition}

\begin{definition}[NTIME]
	\begin{equation}
		NTIME(t(n)) = \{L \mid \text{ esiste una TM non deterministica che
		decide $L$ in tempo $O(t(n))$}\}
	\end{equation}
\end{definition}

Dunque: $NP = \bigcup_k NTIME(n^k)$.

\subsection{NP-completo}

\begin{definition}[Funzione computabile in tempo polinomiale]
	Una funzione $f: \Sigma^* \rightarrow \Sigma^*$ è una funzione computabile 
	in tempo polinomiale se esiste una TM
	$M$ che lavora in tempo polinomiale, tale che si blocca con $f(w)$ sul
	nastro, quando avendo ricevuto $w$ in input.
\end{definition}

\begin{definition}[Riduzione polinomiale]
	Siano $A$ e $B$ due linguaggi. $A$ si riduce in tempo polinomiale a $B$ se 
	esiste una funzione computabile in tempo polinomiale ($ A \leq_p B$) tale 
	che:
	\begin{equation}
		\forall w, w \in A \iff f(w) \in B
	\end{equation}

	$f$ è detta riduzione polinomiale da $A$ a $B$.
\end{definition}

\begin{theorem}[Fondamentale]
	Se $A \leq_p B$ e $B \in P$ allora $A \in P$.
\end{theorem}

\begin{definition}[NP-completo]
	Un linguaggio $L$ è NP-completo se:
	\begin{enumerate}
		\item $L \in NP$;
		\item $\forall L' \in NP, L' \leq_p L$.
	\end{enumerate}
\end{definition}

\begin{theorem}
	Se $B$ è NP-completo e $B \leq_p A$ allora $A$ è NP-completo.
\end{theorem}








\end{document}
